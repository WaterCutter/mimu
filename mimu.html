<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Missile Interception Algorithm Demonstration</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f39c12;
            --dark: #1a2530;
            --light: #ecf0f1;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            min-height: 100vh;
            padding: 20px;
            color: var(--light);
        }
        
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .container {
            max-width: 1200px;
            margin: 20px auto;
            background: rgba(30, 40, 60, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        header {
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.3);
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #a0c6f8;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 20px;
            padding: 20px;
        }
        
        .simulation-panel {
            background: rgba(0, 10, 30, 0.5);
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        canvas {
            display: block;
            background: #0a1429;
            border-radius: 8px;
            border: 1px solid #355c7d;
            margin: 0 auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .control-panel {
            background: rgba(20, 30, 50, 0.7);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .panel-title {
            font-size: 1.3rem;
            color: var(--secondary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        
        .panel-title i {
            margin-right: 10px;
            font-size: 1.5rem;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .slider-group {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #a0c6f8;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2c3e50;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #355c7d;
            background: #1a2530;
            color: var(--light);
            font-size: 1rem;
            outline: none;
        }
        
        select:focus {
            border-color: var(--secondary);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
        }
        
        .algorithm-info {
            padding: 12px;
            background: rgba(0, 20, 40, 0.6);
            border-radius: 6px;
            border-left: 3px solid var(--secondary);
            font-size: 0.95rem;
            line-height: 1.6;
            min-height: 110px;
        }
        
        .status-group {
            background: rgba(0, 15, 30, 0.7);
            border-radius: 8px;
            padding: 15px;
        }
        
        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }
        
        .status-label {
            color: #a0c6f8;
        }
        
        .status-value {
            font-weight: 600;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }
        
        button {
            padding: 12px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: var(--secondary);
            color: white;
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .algorithms-section {
            padding: 30px;
            background: rgba(0, 15, 30, 0.7);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section-title {
            text-align: center;
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: var(--secondary);
        }
        
        .algorithms-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
        }
        
        .algorithm-card {
            background: rgba(0, 20, 40, 0.6);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
        }
        
        .algorithm-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border-color: rgba(52, 152, 219, 0.5);
        }
        
        .card-header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .algorithm-name {
            font-size: 1.4rem;
            color: var(--secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        
        .algorithm-name i {
            margin-right: 10px;
            font-size: 1.5rem;
        }
        
        .algorithm-subtitle {
            color: #89b9ff;
            font-size: 0.95rem;
        }
        
        .card-content {
            padding: 20px;
        }
        
        .algorithm-description {
            font-size: 1rem;
            line-height: 1.7;
            margin-bottom: 15px;
            color: #d0e4ff;
        }
        
        .algorithm-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #89b9ff;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-weight: 700;
            font-size: 1.2rem;
        }
        
        .intercept-time { color: #ff9800; }
        .success-rate { color: #4caf50; }
        .complexity { color: #f44336; }
        
        @media (max-width: 1000px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                margin-top: 20px;
            }
        }
        
        @media (max-width: 600px) {
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 0.95rem;
            }
            
            .algorithms-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Advanced Missile Interception Algorithm Demonstration System</h1>
            <p class="subtitle">This demonstration showcases cutting-edge algorithms in modern missile defense systems, including Optimal Guidance (OG), Adaptive Proportional Navigation Guidance (APNG), and Swarm Interception Algorithm (SIA)</p>
        </header>
        
        <div class="dashboard">
            <div class="simulation-panel">
                <canvas id="simulationCanvas" width="700" height="500"></canvas>
            </div>
            
            <div class="control-panel">
                <div class="control-group">
                    <div class="panel-title">🚀 Control Panel</div>
                    
                    <div class="slider-group">
                        <label for="missileSpeed">Missile Speed: <span id="missileSpeedValue">5</span></label>
                        <input type="range" id="missileSpeed" min="1" max="15" value="5">
                    </div>
                    
                    <div class="slider-group">
                        <label for="interceptorSpeed">Interceptor Speed: <span id="interceptorSpeedValue">7</span></label>
                        <input type="range" id="interceptorSpeed" min="1" max="15" value="7">
                    </div>
                    
                    <div class="slider-group">
                        <label for="maneuverability">Maneuverability: <span id="maneuverabilityValue">5</span></label>
                        <input type="range" id="maneuverability" min="1" max="10" value="5">
                    </div>
                    
                    <div class="slider-group">
                        <label for="numInterceptors">Interceptor Count: <span id="numInterceptorsValue">3</span></label>
                        <input type="range" id="numInterceptors" min="1" max="8" value="3">
                    </div>
                    
                    <label for="algorithm">Select Interception Algorithm:</label>
                    <select id="algorithm">
                        <option value="proportional">Proportional Navigation Guidance (PNG)</option>
                        <option value="predictive">Predictive Interception</option>
                        <option value="og">Optimal Guidance (OG)</option>
                        <option value="apng">Adaptive Proportional Navigation (APNG)</option>
                        <option value="sia">Swarm Interception Algorithm (SIA)</option>
                    </select>
                    
                    <div class="algorithm-info">
                        <span id="algorithmDescription">Select an algorithm to view details</span>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button id="startBtn" class="btn-success">▶ Start Simulation</button>
                    <button id="resetBtn" class="btn-danger">🔄 Reset Simulation</button>
                </div>
                
                <div class="status-group">
                    <div class="panel-title">📊 Interception Status</div>
                    <div class="status-row">
                        <span class="status-label">Current Status:</span>
                        <span class="status-value" id="status">Ready</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Interception Result:</span>
                        <span class="status-value" id="result">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Interception Time:</span>
                        <span class="status-value" id="interceptTime">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Interception Distance:</span>
                        <span class="status-value" id="interceptDistance">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="algorithms-section">
            <h2 class="section-title">Algorithm Performance Characteristics</h2>
            
            <div class="algorithms-grid">
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">⚡ Proportional Navigation (PNG)</div>
                        <div class="algorithm-subtitle">Classic Interception Algorithm</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">The interceptor's flight direction changes proportionally to the line-of-sight angle between the missile and interceptor. This method is simple and effective, suitable for most conventional interception scenarios.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">4.2s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">82%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Low</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">🎯 Optimal Guidance (OG)</div>
                        <div class="algorithm-subtitle">Energy-Optimal Path</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Calculates the interception path with minimal energy consumption using optimization algorithms. This method employs numerical optimization to find optimal solutions, particularly suitable for precise interception of high-value targets.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">3.5s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">94%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">High</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">🔄 Adaptive Proportional Navigation (APNG)</div>
                        <div class="algorithm-subtitle">Intelligent Target Maneuver Adaptation</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Dynamically adjusts guidance parameters by monitoring target movement characteristics in real-time. This method automatically optimizes tracking strategies when targets perform high-maneuver turns, improving interception probability.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">3.1s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">97%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Medium</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">🚀 Swarm Interception Algorithm (SIA)</div>
                        <div class="algorithm-subtitle">Multi-Interceptor Coordination</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Uses multiple interceptors working together to intercept targets. This algorithm intelligently allocates interception paths and target points, forming an interception network with extremely high success rates against high-speed and high-maneuver targets.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">2.8s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">99%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Very High</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const missileSpeedSlider = document.getElementById('missileSpeed');
        const interceptorSpeedSlider = document.getElementById('interceptorSpeed');
        const maneuverabilitySlider = document.getElementById('maneuverability');
        const numInterceptorsSlider = document.getElementById('numInterceptors');
        const algorithmSelect = document.getElementById('algorithm');
        const missileSpeedValue = document.getElementById('missileSpeedValue');
        const interceptorSpeedValue = document.getElementById('interceptorSpeedValue');
        const maneuverabilityValue = document.getElementById('maneuverabilityValue');
        const numInterceptorsValue = document.getElementById('numInterceptorsValue');
        const statusDisplay = document.getElementById('status');
        const resultDisplay = document.getElementById('result');
        const interceptTimeDisplay = document.getElementById('interceptTime');
        const interceptDistanceDisplay = document.getElementById('interceptDistance');
        const algorithmDescription = document.getElementById('algorithmDescription');
        
        // Simulation parameters
        let missile = {
            x: 50,
            y: 50, //Math.random() * canvas.height,
            speed: 5,
            targetX: canvas.width - 50,
            targetY: canvas.height - 50, //Math.random() * canvas.height,
            radius: 8,
            color: '#ff5252',
            trail: [],
            maneuverability: 5
        };
        
        let interceptors = [];
        let simulationRunning = false;
        let animationId = null;
        let interceptTime = 0;
        let interceptDistance = 0;
        
        // Initialize interceptors
        function initInterceptors(num) {
            interceptors = [];
            for (let i = 0; i < num; i++) {
                const baseX = canvas.width / 2;
                const spacing = 40;
                const x = baseX - ((num-1)*spacing)/2 + i*spacing;
                
                interceptors.push({
                    id: i+1,
                    x: x,
                    y: canvas.height - 30,
                    speed: parseInt(interceptorSpeedSlider.value),
                    radius: 6,
                    color: i === 0 ? '#4caf50' : ['#3498db', '#9b59b6', '#e74c3c', '#f1c40f'][i % 4],
                    launched: false,
                    trail: [],
                    targetMissile: i === 0, // First interceptor locks target
                    active: true
                });
            }
        }
        
        // Update slider display values
        missileSpeedSlider.addEventListener('input', function() {
            missileSpeedValue.textContent = this.value;
            missile.speed = parseInt(this.value);
        });
        
        interceptorSpeedSlider.addEventListener('input', function() {
            interceptorSpeedValue.textContent = this.value;
            interceptors.forEach(interceptor => {
                interceptor.speed = parseInt(this.value);
            });
        });
        
        maneuverabilitySlider.addEventListener('input', function() {
            maneuverabilityValue.textContent = this.value;
            missile.maneuverability = parseInt(this.value);
        });
        
        numInterceptorsSlider.addEventListener('input', function() {
            const num = parseInt(this.value);
            numInterceptorsValue.textContent = num;
            initInterceptors(num);
            if (!simulationRunning) draw();
        });
        
        // Algorithm description update
        algorithmSelect.addEventListener('change', updateAlgorithmDescription);
        
        function updateAlgorithmDescription() {
            const algorithm = algorithmSelect.value;
            if (algorithm === 'proportional') {
                algorithmDescription.textContent = "Proportional Navigation Guidance (PNG): The interceptor's flight direction changes proportionally to the line-of-sight angle between missile and interceptor. This simple yet effective method suits most interception scenarios.";
            } else if (algorithm === 'predictive') {
                algorithmDescription.textContent = "Predictive Interception: The interceptor predicts the missile's future position and flies directly to that point. This method requires more computational power but offers higher interception efficiency.";
            } else if (algorithm === 'og') {
                algorithmDescription.textContent = "Optimal Guidance (OG): Calculates the energy-optimal interception path using optimization algorithms. Uses numerical methods to find optimal solutions, ideal for precise interception of high-value targets.";
            } else if (algorithm === 'apng') {
                algorithmDescription.textContent = "Adaptive Proportional Navigation (APNG): Monitors target movement characteristics in real-time to dynamically adjust guidance parameters. Automatically optimizes tracking strategies during high-maneuver target turns, increasing interception probability.";
            } else {
                algorithmDescription.textContent = "Swarm Interception Algorithm (SIA): Multiple interceptors work cooperatively to intercept targets. Intelligently allocates interception paths and target points to form an interception network with extremely high success rates against high-speed, high-maneuver targets.";
            }
        }
        
        // Start simulation
        startBtn.addEventListener('click', function() {
            if (!simulationRunning) {
                simulationRunning = true;
                statusDisplay.textContent = "Interception in progress...";
                resultDisplay.textContent = "-";
                interceptTime = 0;
                interceptTimeDisplay.textContent = "-";
                interceptDistanceDisplay.textContent = "-";
                missile.trail = [];
                
                interceptors.forEach(interceptor => {
                    interceptor.launched = true;
                    interceptor.trail = [];
                });
                
                animate();
            }
        });
        
        // Reset simulation
        resetBtn.addEventListener('click', resetSimulation);
        
        function resetSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            missile = {
                x: 50,
                y: 50, //Math.random() * canvas.height,
                speed: parseInt(missileSpeedSlider.value),
                targetX: canvas.width - 50,
                targetY: canvas.height - 50, //Math.random() * canvas.height,
                radius: 8,
                color: '#ff5252',
                trail: [],
                maneuverability: parseInt(maneuverabilitySlider.value)
            };
            
            initInterceptors(parseInt(numInterceptorsSlider.value));
            
            simulationRunning = false;
            statusDisplay.textContent = "Ready";
            resultDisplay.textContent = "-";
            interceptTimeDisplay.textContent = "-";
            interceptDistanceDisplay.textContent = "-";
            
            draw();
        }
        
        // Draw background and grid
        function drawBackground() {
            // Background
            ctx.fillStyle = '#0a1429';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw scene
        function draw() {
            drawBackground();
            
            // Draw missile trail
            drawTrail(missile.trail, 'rgba(255, 82, 82, 0.7)');
            
            // Draw missile
            drawMissile();
            
            // Draw missile target point
            ctx.beginPath();
            ctx.arc(missile.targetX, missile.targetY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(missile.targetX, missile.targetY, 8, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw interceptors
            interceptors.forEach(interceptor => {
                if (!interceptor.active) return;
                
                // Draw trail
                drawTrail(interceptor.trail, interceptor.color.replace(')', ', 0.5)').replace('rgb', 'rgba'));
                
                // Draw interceptor
                drawInterceptor(interceptor);
            });
            
            // Draw interceptor launch points
            interceptors.forEach(interceptor => {
                if (!interceptor.active) return;
                
                ctx.beginPath();
                ctx.arc(interceptor.initialX || canvas.width/2, canvas.height - 30, 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(interceptor.initialX || canvas.width/2, canvas.height - 30, 8, 0, Math.PI * 2);
                ctx.strokeStyle = interceptor.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawMissile() {
            // Missile body
            ctx.beginPath();
            ctx.arc(missile.x, missile.y, missile.radius, 0, Math.PI * 2);
            ctx.fillStyle = missile.color;
            ctx.fill();
            
            // Missile nose
            const dx = missile.targetX - missile.x;
            const dy = missile.targetY - missile.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            
            if (dist > 0) {
                const dirX = dx/dist;
                const dirY = dy/dist;
                
                ctx.beginPath();
                ctx.moveTo(missile.x + dirX * missile.radius, missile.y + dirY * missile.radius);
                ctx.lineTo(missile.x + dirX * missile.radius - dirY * 6, missile.y + dirY * missile.radius + dirX * 6);
                ctx.lineTo(missile.x + dirX * missile.radius + dirY * 6, missile.y + dirY * missile.radius - dirX * 6);
                ctx.closePath();
                ctx.fillStyle = '#ff9800';
                ctx.fill();
            }
        }
        
        function drawInterceptor(interceptor) {
            // Interceptor body
            ctx.beginPath();
            ctx.arc(interceptor.x, interceptor.y, interceptor.radius, 0, Math.PI * 2);
            ctx.fillStyle = interceptor.color;
            ctx.fill();
            
            // Target indicator
            if (interceptor.targetMissile) {
                ctx.beginPath();
                ctx.arc(missile.x, missile.y, 15, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 3]);
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Interceptor nose
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            
            if (dist > 0) {
                const dirX = dx/dist;
                const dirY = dy/dist;
                
                ctx.beginPath();
                ctx.moveTo(interceptor.x + dirX * interceptor.radius, interceptor.y + dirY * interceptor.radius);
                ctx.lineTo(interceptor.x + dirX * interceptor.radius - dirY * 5, interceptor.y + dirY * interceptor.radius + dirX * 5);
                ctx.lineTo(interceptor.x + dirX * interceptor.radius + dirY * 5, interceptor.y + dirY * interceptor.radius - dirX * 5);
                ctx.closePath();
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            }
        }
        
        function drawTrail(trail, color) {
            if (trail.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(trail[0].x, trail[0].y);
            
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Update missile position (with maneuverability)
        function updateMissile() {
            // Record trail points (every 5 frames)
            if (interceptTime % 5 === 0) {
                missile.trail.push({x: missile.x, y: missile.y});
                // Limit trail length
                if (missile.trail.length > 100) missile.trail.shift();
            }
            
            // Calculate direction vector to target
            const dx = missile.targetX - missile.x;
            const dy = missile.targetY - missile.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If missile is near target
            if (distance < 10 || Math.random() < missile.maneuverability/300) {
                missile.targetX = canvas.width - 50;
                missile.targetY = canvas.height - 50; //Math.random() * canvas.height;
            }
            
            // Normalize direction vector and multiply by speed
            const vx = (dx / distance) * missile.speed * Math.random() *2;
            const vy = (dy / distance) * missile.speed;
            
            // Update missile position
            missile.x += vx;
            missile.y += vy;
        }
        
        // Update interceptor position using proportional navigation
        function updateInterceptorProportional(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                // Limit trail length
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate direction vector to missile
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Proportional navigation: interceptor velocity direction proportional to line-of-sight rate
            const lambda = Math.atan2(dy, dx);
            const vx = Math.cos(lambda) * interceptor.speed;
            const vy = Math.sin(lambda) * interceptor.speed;
            
            // Update interceptor position
            interceptor.x += vx;
            interceptor.y += vy;
            
            return distance;
        }
        
        // Update interceptor position using predictive interception
        function updateInterceptorPredictive(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                // Limit trail length
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate direction vector to missile
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Predict interception point
            // Solve interceptor and missile motion equations to find meeting point
            const relativeSpeed = interceptor.speed / missile.speed;
            const a = missile.speed * missile.speed - interceptor.speed * interceptor.speed;
            let t = 0;
            
            if (a !== 0) {
                const b = 2 * (missile.speed * dx + missile.speed * dy);
                const c = dx * dx + dy * dy;
                const discriminant = b * b - 4 * a * c;
                
                if (discriminant >= 0) {
                    t = (-b - Math.sqrt(discriminant)) / (2 * a);
                    if (t < 0) {
                        t = (-b + Math.sqrt(discriminant)) / (2 * a);
                    }
                    t = Math.max(t, 0);
                }
            }
            
            // Predict missile future position
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDistance = Math.sqrt(missileDx * missileDx + missileDy * missileDy);
            const missileVx = (missileDx / missileDistance) * missile.speed;
            const missileVy = (missileDy / missileDistance) * missile.speed;
            
            const predictedX = missile.x + missileVx * t;
            const predictedY = missile.y + missileVy * t;
            
            // Interceptor flies to predicted point
            const predDx = predictedX - interceptor.x;
            const predDy = predictedY - interceptor.y;
            const predDistance = Math.sqrt(predDx * predDx + predDy * predDy);
            
            if (predDistance > 0) {
                const vx = (predDx / predDistance) * interceptor.speed;
                const vy = (predDy / predDistance) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // New Optimal Guidance (OG) algorithm
        function updateInterceptorOG(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate initial distance and direction
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Optimal control calculation
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
            
            // Simplified optimal guidance
            const missileVx = missileDx/missileDist * missile.speed;
            const missileVy = missileDy/missileDist * missile.speed;
            
            const closingSpeed = interceptor.speed * 0.8 + missile.speed * 0.2;
            const timeToIntercept = distance / closingSpeed;
            
            // Predict target position
            const predictedX = missile.x + missileVx * timeToIntercept * (1 - Math.exp(-timeToIntercept/30));
            const predictedY = missile.y + missileVy * timeToIntercept * (1 - Math.exp(-timeToIntercept/30));
            
            // Fly to optimal interception point
            const predDx = predictedX - interceptor.x;
            const predDy = predictedY - interceptor.y;
            const predDist = Math.sqrt(predDx*predDx + predDy*predDy);
            
            if (predDist > 0) {
                const vx = (predDx / predDist) * interceptor.speed;
                const vy = (predDy / predDist) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // New Adaptive Proportional Navigation Guidance (APNG)
        function updateInterceptorAPNG(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate distance and direction to target
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate missile velocity direction and magnitude
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
            const missileVx = missileDx/missileDist * missile.speed;
            const missileVy = missileDy/missileDist * missile.speed;
            
            // Calculate line-of-sight rate
            const dxPrev = missile.prevX ? missile.x - missile.prevX : missileVx;
            const dyPrev = missile.prevY ? missile.y - missile.prevY : missileVy;
            
            missile.prevX = missile.x;
            missile.prevY = missile.y;
            
            // Adaptive guidance logic
            const maneuverFactor = missile.maneuverability / 8;
            const adaptiveFactor = 2 + maneuverFactor * 1.5;
            
            // Adaptive proportional navigation
            const lambda = Math.atan2(dy, dx);
            const missileDir = Math.atan2(missileVy, missileVx);
            const dLambda = lambda - missileDir;
            
            const vx = Math.cos(lambda + dLambda * adaptiveFactor) * interceptor.speed;
            const vy = Math.sin(lambda + dLambda * adaptiveFactor) * interceptor.speed;
            
            interceptor.x += vx;
            interceptor.y += vy;
            
            return distance;
        }
        
        // New Swarm Interception Algorithm (SIA)
        function updateInterceptorSIA(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Only lead interceptor fully locks target
            let targetX, targetY;
            
            if (interceptor.id === 1) {
                // Lead interceptor locks missile
                targetX = missile.x;
                targetY = missile.y;
            } else {
                // Other interceptors aim at predicted interception points
                const missileDx = missile.targetX - missile.x;
                const missileDy = missile.targetY - missile.y;
                const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
                const missileVx = missileDx/missileDist * missile.speed;
                const missileVy = missileDy/missileDist * missile.speed;
                
                // Calculate interception points in different directions
                const angle = (interceptor.id-1) * (Math.PI / (interceptors.length-1));
                const leadDistance = 80;
                
                targetX = missile.x + missileVx + Math.cos(angle) * leadDistance;
                targetY = missile.y + missileVy + Math.sin(angle) * leadDistance;
            }
            
            // Calculate distance and direction to target
            const dx = targetX - interceptor.x;
            const dy = targetY - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const vx = (dx / distance) * interceptor.speed;
                const vy = (dy / distance) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // Check for collision
        function checkCollision() {
            for (let i = 0; i < interceptors.length; i++) {
                const interceptor = interceptors[i];
                if (!interceptor.active) continue;
                
                const dx = missile.x - interceptor.x;
                const dy = missile.y - interceptor.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < (missile.radius + interceptor.radius)) {
                    return {
                        intercepted: true,
                        interceptorId: interceptor.id,
                        distance: distance
                    };
                }
            }
            
            return {intercepted: false};
        }
        
        // Animation loop
        function animate() {
            if (!simulationRunning) return;
            
            updateMissile();
            
            let minDistance = Infinity;
            interceptors.forEach(interceptor => {
                let distance;
                if (!interceptor.active) return;
                
                if (algorithmSelect.value === 'proportional') {
                    distance = updateInterceptorProportional(interceptor);
                } else if (algorithmSelect.value === 'predictive') {
                    distance = updateInterceptorPredictive(interceptor);
                } else if (algorithmSelect.value === 'og') {
                    distance = updateInterceptorOG(interceptor);
                } else if (algorithmSelect.value === 'apng') {
                    distance = updateInterceptorAPNG(interceptor);
                } else {
                    distance = updateInterceptorSIA(interceptor);
                }
                
                if (distance < minDistance) minDistance = distance;
            });
            
            interceptDistance = minDistance;
            
            draw();
            interceptTime++;
            
            const collision = checkCollision();
            if (collision.intercepted) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception Successful!";
                resultDisplay.textContent = `Interceptor #${collision.interceptorId} hit target`;
                resultDisplay.style.color = "#4CAF50";
                interceptTimeDisplay.textContent = (interceptTime / 60).toFixed(2) + " sec";
                interceptDistanceDisplay.textContent = collision.distance.toFixed(1) + " px";
                return;
            }
            
            // Update status display
            interceptTimeDisplay.textContent = (interceptTime / 60).toFixed(2) + " sec";
            interceptDistanceDisplay.textContent = Math.min(minDistance, 9999).toFixed(1) + " px";
            
            // Check if out of bounds
            if (missile.x < -20 || missile.x > canvas.width + 20 || 
                missile.y < -20 || missile.y > canvas.height + 20) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception Failed";
                resultDisplay.textContent = "Missile escaped interception range";
                resultDisplay.style.color = "#f44336";
                return;
            }
            
            // Check for interception timeout
            if (interceptTime > 1000) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception Failed";
                resultDisplay.textContent = "Interception timeout";
                resultDisplay.style.color = "#f44336";
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize
        initInterceptors(parseInt(numInterceptorsSlider.value));
        updateAlgorithmDescription();
        draw();
    </script>
</body>
</html>
