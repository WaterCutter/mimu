<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Missile Interception Algorithm Demo</title>
    <style>
        /* CSS styles remain the same as original */
        /* ... */
    </style>
</head>
<body>
    <!-- Main container -->
    <div class="container">
        <header>
            <h1>Advanced Missile Interception Algorithm Demo System</h1>
            <p class="subtitle">This demo showcases cutting-edge algorithms in modern missile defense systems, including Optimal Guidance (OG), Adaptive Proportional Navigation Guidance (APNG), and Swarm Interception Algorithm (SIA)</p>
        </header>
        
        <div class="dashboard">
            <!-- Simulation visualization panel -->
            <div class="simulation-panel">
                <canvas id="simulationCanvas" width="700" height="500"></canvas>
            </div>
            
            <!-- Control panel -->
            <div class="control-panel">
                <div class="control-group">
                    <div class="panel-title">ðŸš€ Control Panel</div>
                    
                    <!-- Speed control sliders -->
                    <div class="slider-group">
                        <label for="missileSpeed">Missile Speed: <span id="missileSpeedValue">5</span></label>
                        <input type="range" id="missileSpeed" min="1" max="15" value="5">
                    </div>
                    
                    <div class="slider-group">
                        <label for="interceptorSpeed">Interceptor Speed: <span id="interceptorSpeedValue">7</span></label>
                        <input type="range" id="interceptorSpeed" min="1" max="15" value="7">
                    </div>
                    
                    <div class="slider-group">
                        <label for="maneuverability">Maneuverability: <span id="maneuverabilityValue">5</span></label>
                        <input type="range" id="maneuverability" min="1" max="10" value="5">
                    </div>
                    
                    <div class="slider-group">
                        <label for="numInterceptors">Interceptor Count: <span id="numInterceptorsValue">3</span></label>
                        <input type="range" id="numInterceptors" min="1" max="8" value="3">
                    </div>
                    
                    <!-- Algorithm selection dropdown -->
                    <label for="algorithm">Select Interception Algorithm:</label>
                    <select id="algorithm">
                        <option value="proportional">Proportional Navigation (PNG)</option>
                        <option value="predictive">Predictive Interception</option>
                        <option value="og">Optimal Guidance (OG)</option>
                        <option value="apng">Adaptive Proportional Navigation (APNG)</option>
                        <option value="sia">Swarm Interception Algorithm (SIA)</option>
                    </select>
                    
                    <!-- Algorithm description area -->
                    <div class="algorithm-info">
                        <span id="algorithmDescription">Select an algorithm to view details</span>
                    </div>
                </div>
                
                <!-- Action buttons -->
                <div class="btn-group">
                    <button id="startBtn" class="btn-success">â–¶ Start Simulation</button>
                    <button id="resetBtn" class="btn-danger">ðŸ”„ Reset Simulation</button>
                </div>
                
                <!-- Status display -->
                <div class="status-group">
                    <div class="panel-title">ðŸ“Š Interception Status</div>
                    <div class="status-row">
                        <span class="status-label">Current Status:</span>
                        <span class="status-value" id="status">Ready</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Result:</span>
                        <span class="status-value" id="result">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Interception Time:</span>
                        <span class="status-value" id="interceptTime">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Interception Distance:</span>
                        <span class="status-value" id="interceptDistance">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Algorithm information section -->
        <div class="algorithms-section">
            <h2 class="section-title">Algorithm Performance Characteristics</h2>
            
            <div class="algorithms-grid">
                <!-- PNG algorithm card -->
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">âš¡ Proportional Navigation (PNG)</div>
                        <div class="algorithm-subtitle">Classic interception algorithm</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">The interceptor's flight direction changes proportionally to the line-of-sight angle between missile and interceptor. Simple yet effective for most conventional interception scenarios.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">4.2s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">82%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Low</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- OG algorithm card -->
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">ðŸŽ¯ Optimal Guidance (OG)</div>
                        <div class="algorithm-subtitle">Energy-optimal path</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Calculates the interception path with minimal energy consumption using optimization algorithms. Uses numerical methods to find optimal solutions, ideal for high-value target precision interception.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">3.5s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">94%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">High</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- APNG algorithm card -->
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">ðŸ”„ Adaptive Proportional Navigation (APNG)</div>
                        <div class="algorithm-subtitle">Intelligent target maneuver adaptation</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Dynamically adjusts guidance parameters by monitoring target movement characteristics in real-time. Automatically optimizes tracking strategy during high-maneuverability target turns, improving interception probability.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">3.1s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">97%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Medium</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- SIA algorithm card -->
                <div class="algorithm-card">
                    <div class="card-header">
                        <div class="algorithm-name">ðŸš€ Swarm Interception Algorithm (SIA)</div>
                        <div class="algorithm-subtitle">Multi-interceptor coordination</div>
                    </div>
                    <div class="card-content">
                        <p class="algorithm-description">Uses multiple interceptors working together. Intelligently allocates interception paths and target points to form an interception net, achieving extremely high success rates against high-speed, high-maneuverability targets.</p>
                        <div class="algorithm-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg. Time</div>
                                <div class="stat-value intercept-time">2.8s</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Success Rate</div>
                                <div class="stat-value success-rate">99%</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Complexity</div>
                                <div class="stat-value complexity">Very High</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const missileSpeedSlider = document.getElementById('missileSpeed');
        const interceptorSpeedSlider = document.getElementById('interceptorSpeed');
        const maneuverabilitySlider = document.getElementById('maneuverability');
        const numInterceptorsSlider = document.getElementById('numInterceptors');
        const algorithmSelect = document.getElementById('algorithm');
        const missileSpeedValue = document.getElementById('missileSpeedValue');
        const interceptorSpeedValue = document.getElementById('interceptorSpeedValue');
        const maneuverabilityValue = document.getElementById('maneuverabilityValue');
        const numInterceptorsValue = document.getElementById('numInterceptorsValue');
        const statusDisplay = document.getElementById('status');
        const resultDisplay = document.getElementById('result');
        const interceptTimeDisplay = document.getElementById('interceptTime');
        const interceptDistanceDisplay = document.getElementById('interceptDistance');
        const algorithmDescription = document.getElementById('algorithmDescription');
        
        // Simulation parameters
        let missile = {
            x: 50,
            y: 50,
            speed: 5,
            targetX: canvas.width - 50,
            targetY: canvas.height - 50,
            radius: 8,
            color: '#ff5252',
            trail: [],
            maneuverability: 5
        };
        
        let interceptors = [];
        let simulationRunning = false;
        let animationId = null;
        let interceptTime = 0;
        let interceptDistance = 0;
        
        // Initialize interceptors
        function initInterceptors(num) {
            interceptors = [];
            for (let i = 0; i < num; i++) {
                const baseX = canvas.width / 2;
                const spacing = 40;
                const x = baseX - ((num-1)*spacing)/2 + i*spacing;
                
                interceptors.push({
                    id: i+1,
                    x: x,
                    y: canvas.height - 30,
                    speed: parseInt(interceptorSpeedSlider.value),
                    radius: 6,
                    color: i === 0 ? '#4caf50' : ['#3498db', '#9b59b6', '#e74c3c', '#f1c40f'][i % 4],
                    launched: false,
                    trail: [],
                    targetMissile: i === 0, // First interceptor locks on target
                    active: true
                });
            }
        }
        
        // Update slider display values
        missileSpeedSlider.addEventListener('input', function() {
            missileSpeedValue.textContent = this.value;
            missile.speed = parseInt(this.value);
        });
        
        interceptorSpeedSlider.addEventListener('input', function() {
            interceptorSpeedValue.textContent = this.value;
            interceptors.forEach(interceptor => {
                interceptor.speed = parseInt(this.value);
            });
        });
        
        maneuverabilitySlider.addEventListener('input', function() {
            maneuverabilityValue.textContent = this.value;
            missile.maneuverability = parseInt(this.value);
        });
        
        numInterceptorsSlider.addEventListener('input', function() {
            const num = parseInt(this.value);
            numInterceptorsValue.textContent = num;
            initInterceptors(num);
            if (!simulationRunning) draw();
        });
        
        // Update algorithm description
        algorithmSelect.addEventListener('change', updateAlgorithmDescription);
        
        function updateAlgorithmDescription() {
            const algorithm = algorithmSelect.value;
            if (algorithm === 'proportional') {
                algorithmDescription.textContent = "Proportional Navigation (PNG): The interceptor's flight direction changes proportionally to the line-of-sight angle between missile and interceptor. Simple and effective for most interception scenarios.";
            } else if (algorithm === 'predictive') {
                algorithmDescription.textContent = "Predictive Interception: The interceptor predicts the missile's future position and flies directly to the predicted point. Requires more computational power but offers higher interception efficiency.";
            } else if (algorithm === 'og') {
                algorithmDescription.textContent = "Optimal Guidance (OG): Calculates the interception path with minimal energy consumption using optimization algorithms. Uses numerical methods to find optimal solutions, ideal for high-value target precision interception.";
            } else if (algorithm === 'apng') {
                algorithmDescription.textContent = "Adaptive Proportional Navigation (APNG): Dynamically adjusts guidance parameters by monitoring target movement characteristics in real-time. Automatically optimizes tracking strategy during high-maneuverability target turns.";
            } else {
                algorithmDescription.textContent = "Swarm Interception Algorithm (SIA): Uses multiple interceptors working together. Intelligently allocates interception paths and target points to form an interception net, achieving extremely high success rates against high-speed, high-maneuverability targets.";
            }
        }
        
        // Start simulation
        startBtn.addEventListener('click', function() {
            if (!simulationRunning) {
                simulationRunning = true;
                statusDisplay.textContent = "Interception in progress...";
                resultDisplay.textContent = "-";
                interceptTime = 0;
                interceptTimeDisplay.textContent = "-";
                interceptDistanceDisplay.textContent = "-";
                missile.trail = [];
                
                interceptors.forEach(interceptor => {
                    interceptor.launched = true;
                    interceptor.trail = [];
                });
                
                animate();
            }
        });
        
        // Reset simulation
        resetBtn.addEventListener('click', resetSimulation);
        
        function resetSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            missile = {
                x: 50,
                y: 50,
                speed: parseInt(missileSpeedSlider.value),
                targetX: canvas.width - 50,
                targetY: canvas.height - 50,
                radius: 8,
                color: '#ff5252',
                trail: [],
                maneuverability: parseInt(maneuverabilitySlider.value)
            };
            
            initInterceptors(parseInt(numInterceptorsSlider.value));
            
            simulationRunning = false;
            statusDisplay.textContent = "Ready";
            resultDisplay.textContent = "-";
            interceptTimeDisplay.textContent = "-";
            interceptDistanceDisplay.textContent = "-";
            
            draw();
        }
        
        // Draw background and grid
        function drawBackground() {
            // Background
            ctx.fillStyle = '#0a1429';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw scene
        function draw() {
            drawBackground();
            
            // Draw missile trail
            drawTrail(missile.trail, 'rgba(255, 82, 82, 0.7)');
            
            // Draw missile
            drawMissile();
            
            // Draw missile target point
            ctx.beginPath();
            ctx.arc(missile.targetX, missile.targetY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(missile.targetX, missile.targetY, 8, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw interceptors
            interceptors.forEach(interceptor => {
                if (!interceptor.active) return;
                
                // Draw trail
                drawTrail(interceptor.trail, interceptor.color.replace(')', ', 0.5)').replace('rgb', 'rgba'));
                
                // Draw interceptor
                drawInterceptor(interceptor);
            });
            
            // Draw interceptor launch points
            interceptors.forEach(interceptor => {
                if (!interceptor.active) return;
                
                ctx.beginPath();
                ctx.arc(interceptor.initialX || canvas.width/2, canvas.height - 30, 5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(interceptor.initialX || canvas.width/2, canvas.height - 30, 8, 0, Math.PI * 2);
                ctx.strokeStyle = interceptor.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawMissile() {
            // Missile body
            ctx.beginPath();
            ctx.arc(missile.x, missile.y, missile.radius, 0, Math.PI * 2);
            ctx.fillStyle = missile.color;
            ctx.fill();
            
            // Missile head
            const dx = missile.targetX - missile.x;
            const dy = missile.targetY - missile.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            
            if (dist > 0) {
                const dirX = dx/dist;
                const dirY = dy/dist;
                
                ctx.beginPath();
                ctx.moveTo(missile.x + dirX * missile.radius, missile.y + dirY * missile.radius);
                ctx.lineTo(missile.x + dirX * missile.radius - dirY * 6, missile.y + dirY * missile.radius + dirX * 6);
                ctx.lineTo(missile.x + dirX * missile.radius + dirY * 6, missile.y + dirY * missile.radius - dirX * 6);
                ctx.closePath();
                ctx.fillStyle = '#ff9800';
                ctx.fill();
            }
        }
        
        function drawInterceptor(interceptor) {
            // Interceptor body
            ctx.beginPath();
            ctx.arc(interceptor.x, interceptor.y, interceptor.radius, 0, Math.PI * 2);
            ctx.fillStyle = interceptor.color;
            ctx.fill();
            
            // Target indicator
            if (interceptor.targetMissile) {
                ctx.beginPath();
                ctx.arc(missile.x, missile.y, 15, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([5, 3]);
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Interceptor head
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const dist = Math.sqrt(dx*dx+dy*dy);
            
            if (dist > 0) {
                const dirX = dx/dist;
                const dirY = dy/dist;
                
                ctx.beginPath();
                ctx.moveTo(interceptor.x + dirX * interceptor.radius, interceptor.y + dirY * interceptor.radius);
                ctx.lineTo(interceptor.x + dirX * interceptor.radius - dirY * 5, interceptor.y + dirY * interceptor.radius + dirX * 5);
                ctx.lineTo(interceptor.x + dirX * interceptor.radius + dirY * 5, interceptor.y + dirY * interceptor.radius - dirX * 5);
                ctx.closePath();
                ctx.fillStyle = '#ffffff';
                ctx.fill();
            }
        }
        
        function drawTrail(trail, color) {
            if (trail.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(trail[0].x, trail[0].y);
            
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Update missile position (with maneuverability)
        function updateMissile() {
            // Record trail points (every 5 frames)
            if (interceptTime % 5 === 0) {
                missile.trail.push({x: missile.x, y: missile.y});
                // Limit trail length
                if (missile.trail.length > 100) missile.trail.shift();
            }
            
            // Calculate direction vector to target
            const dx = missile.targetX - missile.x;
            const dy = missile.targetY - missile.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If missile is close to target
            if (distance < 10 || Math.random() < missile.maneuverability/300) {
                missile.targetX = canvas.width - 50;
                missile.targetY = canvas.height - 50;
            }
            
            // Normalize direction vector and multiply by speed
            const vx = (dx / distance) * missile.speed * Math.random() *2;
            const vy = (dy / distance) * missile.speed;
            
            // Update missile position
            missile.x += vx;
            missile.y += vy;
        }
        
        // Update interceptor position using proportional navigation
        function updateInterceptorProportional(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                // Limit trail length
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate direction vector to missile
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Proportional navigation: interceptor velocity direction proportional to LOS rate
            const lambda = Math.atan2(dy, dx);
            const vx = Math.cos(lambda) * interceptor.speed;
            const vy = Math.sin(lambda) * interceptor.speed;
            
            // Update interceptor position
            interceptor.x += vx;
            interceptor.y += vy;
            
            return distance;
        }
        
        // Update interceptor position using predictive interception
        function updateInterceptorPredictive(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                // Limit trail length
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate direction vector to missile
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Predict interception point
            // Solve equations of motion to find meeting point
            const relativeSpeed = interceptor.speed / missile.speed;
            const a = missile.speed * missile.speed - interceptor.speed * interceptor.speed;
            let t = 0;
            
            if (a !== 0) {
                const b = 2 * (missile.speed * dx + missile.speed * dy);
                const c = dx * dx + dy * dy;
                const discriminant = b * b - 4 * a * c;
                
                if (discriminant >= 0) {
                    t = (-b - Math.sqrt(discriminant)) / (2 * a);
                    if (t < 0) {
                        t = (-b + Math.sqrt(discriminant)) / (2 * a);
                    }
                    t = Math.max(t, 0);
                }
            }
            
            // Predict missile future position
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDistance = Math.sqrt(missileDx * missileDx + missileDy * missileDy);
            const missileVx = (missileDx / missileDistance) * missile.speed;
            const missileVy = (missileDy / missileDistance) * missile.speed;
            
            const predictedX = missile.x + missileVx * t;
            const predictedY = missile.y + missileVy * t;
            
            // Interceptor flies to predicted point
            const predDx = predictedX - interceptor.x;
            const predDy = predictedY - interceptor.y;
            const predDistance = Math.sqrt(predDx * predDx + predDy * predDy);
            
            if (predDistance > 0) {
                const vx = (predDx / predDistance) * interceptor.speed;
                const vy = (predDy / predDistance) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // Optimal Guidance (OG) algorithm
        function updateInterceptorOG(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate initial distance and direction
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Optimal control calculation
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
            
            // Simplified optimal guidance
            const missileVx = missileDx/missileDist * missile.speed;
            const missileVy = missileDy/missileDist * missile.speed;
            
            const closingSpeed = interceptor.speed * 0.8 + missile.speed * 0.2;
            const timeToIntercept = distance / closingSpeed;
            
            // Predict target position
            const predictedX = missile.x + missileVx * timeToIntercept * (1 - Math.exp(-timeToIntercept/30));
            const predictedY = missile.y + missileVy * timeToIntercept * (1 - Math.exp(-timeToIntercept/30));
            
            // Fly to optimal interception point
            const predDx = predictedX - interceptor.x;
            const predDy = predictedY - interceptor.y;
            const predDist = Math.sqrt(predDx*predDx + predDy*predDy);
            
            if (predDist > 0) {
                const vx = (predDx / predDist) * interceptor.speed;
                const vy = (predDy / predDist) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // Adaptive Proportional Navigation Guidance (APNG)
        function updateInterceptorAPNG(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Calculate distance and direction to target
            const dx = missile.x - interceptor.x;
            const dy = missile.y - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate missile velocity direction and magnitude
            const missileDx = missile.targetX - missile.x;
            const missileDy = missile.targetY - missile.y;
            const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
            const missileVx = missileDx/missileDist * missile.speed;
            const missileVy = missileDy/missileDist * missile.speed;
            
            // Calculate line-of-sight rate
            const dxPrev = missile.prevX ? missile.x - missile.prevX : missileVx;
            const dyPrev = missile.prevY ? missile.y - missile.prevY : missileVy;
            
            missile.prevX = missile.x;
            missile.prevY = missile.y;
            
            // Adaptive guidance logic
            const maneuverFactor = missile.maneuverability / 8;
            const adaptiveFactor = 2 + maneuverFactor * 1.5;
            
            // Adaptive proportional navigation
            const lambda = Math.atan2(dy, dx);
            const missileDir = Math.atan2(missileVy, missileVx);
            const dLambda = lambda - missileDir;
            
            const vx = Math.cos(lambda + dLambda * adaptiveFactor) * interceptor.speed;
            const vy = Math.sin(lambda + dLambda * adaptiveFactor) * interceptor.speed;
            
            interceptor.x += vx;
            interceptor.y += vy;
            
            return distance;
        }
        
        // Swarm Interception Algorithm (SIA)
        function updateInterceptorSIA(interceptor) {
            if (!interceptor.active) return false;
            
            // Record trail points
            if (interceptTime % 5 === 0) {
                interceptor.trail.push({x: interceptor.x, y: interceptor.y});
                if (interceptor.trail.length > 100) interceptor.trail.shift();
            }
            
            // Only primary interceptor fully locks on target
            let targetX, targetY;
            
            if (interceptor.id === 1) {
                // Primary interceptor locks on missile
                targetX = missile.x;
                targetY = missile.y;
            } else {
                // Other interceptors aim at predicted interception points
                const missileDx = missile.targetX - missile.x;
                const missileDy = missile.targetY - missile.y;
                const missileDist = Math.sqrt(missileDx*missileDx + missileDy*missileDy);
                const missileVx = missileDx/missileDist * missile.speed;
                const missileVy = missileDy/missileDist * missile.speed;
                
                // Calculate interception points in different directions
                const angle = (interceptor.id-1) * (Math.PI / (interceptors.length-1));
                const leadDistance = 80;
                
                targetX = missile.x + missileVx + Math.cos(angle) * leadDistance;
                targetY = missile.y + missileVy + Math.sin(angle) * leadDistance;
            }
            
            // Calculate distance and direction to target
            const dx = targetX - interceptor.x;
            const dy = targetY - interceptor.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const vx = (dx / distance) * interceptor.speed;
                const vy = (dy / distance) * interceptor.speed;
                
                interceptor.x += vx;
                interceptor.y += vy;
            }
            
            return distance;
        }
        
        // Check for collision
        function checkCollision() {
            for (let i = 0; i < interceptors.length; i++) {
                const interceptor = interceptors[i];
                if (!interceptor.active) continue;
                
                const dx = missile.x - interceptor.x;
                const dy = missile.y - interceptor.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < (missile.radius + interceptor.radius)) {
                    return {
                        intercepted: true,
                        interceptorId: interceptor.id,
                        distance: distance
                    };
                }
            }
            
            return {intercepted: false};
        }
        
        // Animation loop
        function animate() {
            if (!simulationRunning) return;
            
            updateMissile();
            
            let minDistance = Infinity;
            interceptors.forEach(interceptor => {
                let distance;
                if (!interceptor.active) return;
                
                if (algorithmSelect.value === 'proportional') {
                    distance = updateInterceptorProportional(interceptor);
                } else if (algorithmSelect.value === 'predictive') {
                    distance = updateInterceptorPredictive(interceptor);
                } else if (algorithmSelect.value === 'og') {
                    distance = updateInterceptorOG(interceptor);
                } else if (algorithmSelect.value === 'apng') {
                    distance = updateInterceptorAPNG(interceptor);
                } else {
                    distance = updateInterceptorSIA(interceptor);
                }
                
                if (distance < minDistance) minDistance = distance;
            });
            
            interceptDistance = minDistance;
            
            draw();
            interceptTime++;
            
            const collision = checkCollision();
            if (collision.intercepted) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception successful!";
                resultDisplay.textContent = `Interceptor #${collision.interceptorId} hit target`;
                resultDisplay.style.color = "#4CAF50";
                interceptTimeDisplay.textContent = (interceptTime / 60).toFixed(2) + " sec";
                interceptDistanceDisplay.textContent = collision.distance.toFixed(1) + " px";
                return;
            }
            
            // Update status display
            interceptTimeDisplay.textContent = (interceptTime / 60).toFixed(2) + " sec";
            interceptDistanceDisplay.textContent = Math.min(minDistance, 9999).toFixed(1) + " px";
            
            // Check if out of bounds
            if (missile.x < -20 || missile.x > canvas.width + 20 || 
                missile.y < -20 || missile.y > canvas.height + 20) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception failed";
                resultDisplay.textContent = "Missile escaped interception range";
                resultDisplay.style.color = "#f44336";
                return;
            }
            
            // Check for timeout
            if (interceptTime > 1000) {
                simulationRunning = false;
                statusDisplay.textContent = "Interception failed";
                resultDisplay.textContent = "Interception timeout";
                resultDisplay.style.color = "#f44336";
                return;
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize
        initInterceptors(parseInt(numInterceptorsSlider.value));
        updateAlgorithmDescription();
        draw();
    </script>
</body>
</html>
